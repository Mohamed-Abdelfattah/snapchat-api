app flow after getting the access token

- any agent/browser will hit the url of the website
- for any request to the flask server a check for the access token should run and run a refresh expiry and run a function to refresh token and save it into environmental variable if needed
- flask server will then send the html of index page
- the frontend will responsible for sending requests to the flask endpoints that will connect to the snapchat api

- for the random users:

  - generate random users with faker
  - display on the frontend
  - save the list to text file
    - this text file will work as database
    - each file represents a data of the segment
    - named as "data", located in the folder that have the segment name (user can save and edit segment name)
    - should be updated whenever the user modifies the data
    -

---

What I done:

- tested all the endpoints to the snapchat api and kinda figured how they work
- created and committed feature: generating random list of users
- asserted that when creating the random list a new name that matches the format
- when the route for generating the random list is hit a response contains random users and a temp segment name sent from the backend

- created the ui for loading segment from the backend and populating the dropdown menu with existing segments in the backend
- created skeleton for the save changes button handler in the frontend using server-sent-events
- created skeleton for route of saving new segment in the backend using server-sent-events

---

what i need todo:

- save the generated random list in a folder on the backend in the segments folder, that folder should be named using a name that user can edit on the frontend:
  to solve the problem of duplicate folder names i plan to use the id that will be generated by the snapchat-api to construct the folder name using format "{list name} +++ {list id from snapchat}"

- the processing of the segment action that user do will be a blocking operation on the server so that when a request to save changes for a list is sent :

  - the processing sequence will be initiated and a server event of this operation will be created as the frontend app will be frozen there should be no more requests to the server
  - but if another client makes a request there will be an ongoing operation that has its own sse updates and for that i need to associate the id of the segment that being processed with the request to the sse updates "/updates/{segment id}"

- upon generating the random list:

  - a response contains random users and a temp segment name sent from the backend and this is done so that the segment name or the users list data can be edited and when pressing on save new segment button:

    - a request containing the edited (or not edited) users data and name will be sent to the backend, for the name it will be constructed as: "{segment name} +++ { placeholder for segment id}" before being sent to the backend
    - using the name sent from the backend a new folder will be created and payload user data will be saved in "raw_data.txt" file inside the segment folder --- message = "saving data"
    - create a new segment using snapchat api and get the id from the response and save it modify the name of the folder to "{list name} +++ {list id from snapchat}" --- message = "creating new customer segment"
    - the data should be processed to create and save files that will be sent to the snapchat api (emails file and phone numbers file) --- message = "processing data"
    - send the processed files to the snapchat api --- message = "adding users to segment"
    - wait for the api to finish --- message = "finished" or "failed"
    - for each step in the above the message should be displayed on the frontend

  - to achieve the above i need to implement the frontend of a button that saves the new segment

- will give the frontend the ability to load segments from the backend to view and edit and so a state is needed to determine:

  - the current active segment
  - if the current active segment is a new segment or not
  - the edit state of the segment (whether frontend is in edit mode or not)
  - the new data of the segment which is edited and will be saved in the backend:
    - this data will be a copy of the current active segment
    - should be updated whenever the user modifies the data
    - should be populated/created when the user clicks on the edit button

- will give the frontend the ability to edit the segment name and the data of the users list and to do so:

  - there will be a button that controls the edit state of the segment name and data:
    - when the button is clicked the edit state will be toggled to editing
    - state will be changed to include the new edited data which will
    - the ui will be updated so that every field will be editable and the save button will be enabled
  - there will be a "save changes" button:
    - this button will be disabled all the time except for when the user clicks edit button
    - this button will handle 2 states:
      - if new segment:
        - the text shown in the button should be "save new segment"
        - when clicked a POST request to '/segments' will be sent to the backend, which will go throw the flow of "save the generated random list" from the above
        - initiate the SSE event to get the updates and display them on the frontend
      - if not new segment:
        - the text shown in the button should be "save changes"
        - when clicked a PUT request to '/segments/{segment_id}' will be sent to the backend, which will go throw the flow of "edit segment" from the below
        - initiate the SSE event to get the updates and display them on the frontend

- when the frontend page loads it should fetch the already existing segments from the backend and display them in a dropdown menu so that the user can select from them

  - create a button that have down arrow that will open the dropdown menu
  - fetch the data from the backend and populate the dropdown menu upon page loading
  - set the backend route that responds to that request to '/segments'

- when the user selects a segment from the dropdown menu it should be set as the active segment in the frontend and its data should be fetched and displayed on the frontend

- divide the action area into 4 sections with tiny labels:

  - load segments + dropdown menu button "open segment"
  - create a new segment + generate random list button
  - edit segment + delete segment buttons
  - save changes + reset changes buttons

- TODO: optimize performance when user tries to generate 100000 random users:
  - the backend takes time to generate large number of users
  - the frontend fails to display the data in one table as the browser runs out of memory
